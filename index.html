<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backlog Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .app-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 800px;
            max-height: 90vh;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header {
            background: rgba(255, 255, 255, 0.8);
            padding: 20px 30px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }

        .header h1 {
            color: #333;
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 15px;
        }

        .input-container {
            display: flex;
            gap: 10px;
        }

        .task-input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid rgba(102, 126, 234, 0.2);
            border-radius: 12px;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.9);
            transition: all 0.3s ease;
        }

        .task-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .add-btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .add-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
        }

        .content {
            max-height: 60vh;
            overflow-y: auto;
            padding: 0 30px 30px;
        }

        .date-section {
            margin-bottom: 30px;
        }

        .date-header {
            position: sticky;
            top: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px 0;
            margin: 20px 0 15px;
            border-bottom: 2px solid rgba(102, 126, 234, 0.1);
            font-size: 18px;
            font-weight: 600;
            color: #667eea;
        }

        .task-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 12px;
            margin-bottom: 8px;
            transition: all 0.3s ease;
            border-left: 4px solid transparent;
        }

        .task-item:hover {
            background: rgba(255, 255, 255, 0.9);
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .task-item.completed {
            opacity: 0.6;
            border-left-color: #4CAF50;
        }

        .task-item.pending {
            border-left-color: #ff9800;
        }

        .checkbox {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #ddd;
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .checkbox.checked {
            background: #4CAF50;
            border-color: #4CAF50;
        }

        .checkbox.checked::after {
            content: '‚úì';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
        }

        .task-text {
            flex: 1;
            font-size: 16px;
            color: #333;
            line-height: 1.4;
        }

        .task-text.completed {
            text-decoration: line-through;
            color: #888;
        }

        .task-time {
            font-size: 12px;
            color: #888;
            font-weight: 500;
        }

        .delete-btn {
            background: #ff4757;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 12px;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .task-item:hover .delete-btn {
            opacity: 1;
        }

        .delete-btn:hover {
            background: #ff3742;
            transform: scale(1.1);
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #888;
        }

        .empty-state svg {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        /* Custom scrollbar */
        .content::-webkit-scrollbar {
            width: 6px;
        }

        .content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 3px;
        }

        .content::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.3);
            border-radius: 3px;
        }

        .content::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.5);
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            font-size: 14px;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #666;
        }

        .stat-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .stat-dot.pending {
            background: #ff9800;
        }

        .stat-dot.completed {
            background: #4CAF50;
        }

        .tabs {
    display: flex;
    border-bottom: 1px solid #ddd;
}

.tab {
    flex: 1;
    padding: 12px;
    background: #f5f5f5;
    border: none;
    cursor: pointer;
    font-size: 16px;
}

.tab.active {
    background: #fff;
    font-weight: bold;
    border-bottom: 2px solid #667eea;
}

.section {
    display: none;
}

.section.active {
    display: block;
}

#scribbleArea {
    width: 100%;
    height: 70vh;
    padding: 20px;
    font-family: monospace;
    font-size: 18px;
    line-height: 1.6;
    border: none;
    outline: none;
    resize: none;
    background: #fafafa;
    overflow-y: auto;
}

/* AI Section Styles */
.ai-container {
    padding: 20px 30px;
    max-height: 70vh;
    overflow-y: auto;
}

.ai-config-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding: 15px 20px;
    background: rgba(255, 255, 255, 0.7);
    border-radius: 12px;
    border-left: 4px solid #667eea;
}

.config-btn {
    padding: 10px 20px;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border: none;
    border-radius: 10px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}

.config-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
}

.config-status {
    font-size: 13px;
    color: #666;
    font-weight: 500;
}

.config-status.success {
    color: #4CAF50;
}

.config-status.error {
    color: #ff4757;
}

/* Modal Styles */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(5px);
}

.modal.show {
    display: flex;
    justify-content: center;
    align-items: center;
}

.modal-content {
    background: white;
    border-radius: 16px;
    width: 90%;
    max-width: 500px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    animation: modalSlideIn 0.3s ease;
}

@keyframes modalSlideIn {
    from {
        transform: translateY(-50px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px 25px;
    border-bottom: 1px solid #eee;
}

.modal-header h2 {
    margin: 0;
    font-size: 20px;
    color: #333;
}

.close-modal {
    font-size: 32px;
    font-weight: 300;
    color: #999;
    cursor: pointer;
    transition: color 0.3s ease;
    line-height: 1;
}

.close-modal:hover {
    color: #333;
}

.modal-body {
    padding: 25px;
}

.config-section {
    margin-bottom: 20px;
}

.config-section label {
    display: block;
    margin-bottom: 8px;
    font-weight: 600;
    color: #333;
    font-size: 14px;
}

.config-input,
.model-select {
    width: 100%;
    padding: 12px 16px;
    border: 2px solid rgba(102, 126, 234, 0.2);
    border-radius: 10px;
    font-size: 14px;
    background: rgba(255, 255, 255, 0.9);
    transition: all 0.3s ease;
}

.config-input:focus,
.model-select:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

.test-btn {
    padding: 10px 20px;
    background: #667eea;
    color: white;
    border: none;
    border-radius: 10px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-bottom: 10px;
}

.test-btn:hover {
    background: #5568d3;
}

.test-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.connection-status {
    padding: 10px 15px;
    border-radius: 8px;
    font-size: 13px;
    min-height: 20px;
}

.connection-status.success {
    background: rgba(76, 175, 80, 0.1);
    color: #4CAF50;
    border: 1px solid rgba(76, 175, 80, 0.3);
}

.connection-status.error {
    background: rgba(255, 71, 87, 0.1);
    color: #ff4757;
    border: 1px solid rgba(255, 71, 87, 0.3);
}

.connection-status.info {
    background: rgba(102, 126, 234, 0.1);
    color: #667eea;
    border: 1px solid rgba(102, 126, 234, 0.3);
}

.modal-footer {
    padding: 20px 25px;
    border-top: 1px solid #eee;
    display: flex;
    justify-content: flex-end;
}

.save-config-btn {
    padding: 12px 30px;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border: none;
    border-radius: 10px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}

.save-config-btn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
}

.save-config-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.ai-subsection {
    margin-bottom: 30px;
    padding: 20px;
    background: rgba(255, 255, 255, 0.7);
    border-radius: 12px;
    border-left: 4px solid #667eea;
}

.ai-subsection h3 {
    color: #667eea;
    font-size: 18px;
    margin-bottom: 15px;
    font-weight: 600;
}

.prompt-input-container {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
}

.prompt-input {
    flex: 1;
    padding: 12px 16px;
    border: 2px solid rgba(102, 126, 234, 0.2);
    border-radius: 12px;
    font-size: 14px;
    background: rgba(255, 255, 255, 0.9);
    transition: all 0.3s ease;
}

.prompt-input:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

.save-prompt-btn {
    padding: 12px 24px;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border: none;
    border-radius: 12px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
}

.save-prompt-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
}

.prompts-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-height: 200px;
    overflow-y: auto;
}

.prompt-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 16px;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 2px solid transparent;
}

.prompt-item:hover {
    background: rgba(255, 255, 255, 1);
    border-color: #667eea;
    transform: translateX(5px);
}

.prompt-item.selected {
    background: rgba(102, 126, 234, 0.1);
    border-color: #667eea;
}

.prompt-text {
    flex: 1;
    font-size: 14px;
    color: #333;
}

.delete-prompt-btn {
    background: #ff4757;
    color: white;
    border: none;
    border-radius: 6px;
    padding: 4px 8px;
    cursor: pointer;
    font-size: 11px;
    transition: all 0.3s ease;
}

.delete-prompt-btn:hover {
    background: #ff3742;
    transform: scale(1.1);
}

.user-input {
    width: 100%;
    min-height: 120px;
    padding: 12px 16px;
    border: 2px solid rgba(102, 126, 234, 0.2);
    border-radius: 12px;
    font-size: 14px;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: rgba(255, 255, 255, 0.9);
    transition: all 0.3s ease;
    resize: vertical;
    margin-bottom: 15px;
}

.user-input:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

.generate-btn {
    width: 100%;
    padding: 14px;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border: none;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}

.generate-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
}

.generate-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
}

.ai-response {
    min-height: 150px;
    max-height: 300px;
    overflow-y: auto;
    padding: 16px;
    background: rgba(255, 255, 255, 0.9);
    border: 2px solid rgba(102, 126, 234, 0.2);
    border-radius: 12px;
    font-size: 14px;
    line-height: 1.6;
    color: #333;
    margin-bottom: 15px;
    white-space: pre-wrap;
    word-wrap: break-word;
}

.copy-btn {
    width: 100%;
    padding: 12px;
    background: #4CAF50;
    color: white;
    border: none;
    border-radius: 12px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
}

.copy-btn:hover {
    background: #45a049;
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(76, 175, 80, 0.3);
}

.copy-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
}

.loading {
    opacity: 0.7;
    pointer-events: none;
}

.ai-container::-webkit-scrollbar,
.prompts-list::-webkit-scrollbar,
.ai-response::-webkit-scrollbar {
    width: 6px;
}

.ai-container::-webkit-scrollbar-track,
.prompts-list::-webkit-scrollbar-track,
.ai-response::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.05);
    border-radius: 3px;
}

.ai-container::-webkit-scrollbar-thumb,
.prompts-list::-webkit-scrollbar-thumb,
.ai-response::-webkit-scrollbar-thumb {
    background: rgba(102, 126, 234, 0.3);
    border-radius: 3px;
}

.ai-container::-webkit-scrollbar-thumb:hover,
.prompts-list::-webkit-scrollbar-thumb:hover,
.ai-response::-webkit-scrollbar-thumb:hover {
    background: rgba(102, 126, 234, 0.5);
}


    </style>
</head>
<body>
<div class="app-container">
    <!-- Tabs -->
    <div class="tabs">
        <button id="tasksTab" class="tab active">üìù Tasks</button>
        <button id="scribbleTab" class="tab">‚úçÔ∏è Scribble</button>
        <button id="aiTab" class="tab">ü§ñ AI</button>
    </div>

    <!-- Tasks Section -->
    <div id="tasksSection" class="section active">
        <div class="header">
            <h1>üìù Backlog Tracker</h1>
            <div class="stats" id="stats"></div>
            <div class="input-container">
                <input type="text" class="task-input" id="taskInput" placeholder="What needs to be done?" maxlength="200">
                <button class="add-btn" id="addBtn">Add Task</button>
            </div>
        </div>
        
        <div class="content" id="content">
            <div class="empty-state" id="emptyState">
                <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/>
                </svg>
                <p>No tasks yet. Add your first backlog item above!</p>
            </div>
        </div>
    </div>

    <!-- Scribble Section -->
    <div id="scribbleSection" class="section">
        <textarea id="scribbleArea" placeholder="Start scribbling your thoughts..."></textarea>
    </div>

    <!-- AI Section -->
    <div id="aiSection" class="section">
        <div class="ai-container">
            <div class="ai-config-header">
                <button id="configBtn" class="config-btn">‚öôÔ∏è Configure Ollama</button>
                <div id="configStatus" class="config-status"></div>
            </div>
            
            <div class="ai-subsection">
                <h3>üìù Saved Prompts</h3>
                <div class="prompt-input-container">
                    <input type="text" id="promptInput" class="prompt-input" placeholder="Enter a prompt template (e.g., 'Reformat the given text with proper english')">
                    <button id="savePromptBtn" class="save-prompt-btn">Save</button>
                </div>
                <div id="promptsList" class="prompts-list"></div>
            </div>
            
            <div class="ai-subsection">
                <h3>üí≠ User Input</h3>
                <textarea id="userInput" class="user-input" placeholder="Enter your text here (e.g., 'The candidate can be selected, but nead to upskil on microseruics, aws and javvv fundamentaal')"></textarea>
                <button id="generateBtn" class="generate-btn">Generate Response</button>
            </div>
            
            <div class="ai-subsection">
                <h3>‚ú® AI Response</h3>
                <div id="aiResponse" class="ai-response">Response will appear here...</div>
                <button id="copyResponseBtn" class="copy-btn">üìã Copy Response</button>
            </div>
        </div>
    </div>

    <!-- Configuration Modal -->
    <div id="configModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>‚öôÔ∏è Ollama Configuration</h2>
                <span class="close-modal" id="closeModal">&times;</span>
            </div>
            <div class="modal-body">
                <div class="config-section">
                    <label>Ollama Hostname:</label>
                    <input type="text" id="ollamaHost" class="config-input" placeholder="localhost" value="localhost">
                </div>
                <div class="config-section">
                    <label>Ollama Port:</label>
                    <input type="text" id="ollamaPort" class="config-input" placeholder="11434" value="11434">
                </div>
                <div class="config-section">
                    <button id="testConnectionBtn" class="test-btn">Test Connection</button>
                    <div id="connectionStatus" class="connection-status"></div>
                </div>
                <div class="config-section" id="modelSection" style="display: none;">
                    <label>Select Model:</label>
                    <select id="modelSelect" class="model-select">
                        <option value="">-- Select a model --</option>
                    </select>
                </div>
            </div>
            <div class="modal-footer">
                <button id="saveConfigBtn" class="save-config-btn" disabled>Save Configuration</button>
            </div>
        </div>
    </div>
</div>


    <script>
        class BacklogTracker {
            constructor() {
                this.tasks = [];
                this.taskInput = document.getElementById('taskInput');
                this.addBtn = document.getElementById('addBtn');
                this.content = document.getElementById('content');
                this.emptyState = document.getElementById('emptyState');
                this.stats = document.getElementById('stats');
                
                this.init();
            }

            async init() {
                this.tasks = await this.loadTasks();
                this.addBtn.addEventListener('click', () => this.addTask());
                this.taskInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.addTask();
                });
                
                this.render();
            }

 

            async addTask() {
                const text = this.taskInput.value.trim();
                if (!text) return;

                const task = {
                    id: Date.now().toString(),
                    text: text,
                    completed: false,
                    createdAt: new Date().toISOString()
                };

                this.tasks.unshift(task);
                await this.saveTasks();
                this.taskInput.value = '';
                this.render();
            }

            async toggleTask(id) {
                const task = this.tasks.find(t => t.id === id);
                if (task) {
                    task.completed = !task.completed;
                    task.completedAt = task.completed ? new Date().toISOString() : null;
                    await this.saveTasks();
                    this.render();
                }
            }

            async deleteTask(id) {
                this.tasks = this.tasks.filter(t => t.id !== id);
                await this.saveTasks();
                this.render();
            }

            groupTasksByDate() {
                const groups = {};
                
                this.tasks.forEach(task => {
                    const date = new Date(task.createdAt);
                    const dateKey = date.toDateString();
                    
                    if (!groups[dateKey]) {
                        groups[dateKey] = [];
                    }
                    groups[dateKey].push(task);
                });

                return groups;
            }

            formatDate(dateString) {
                const date = new Date(dateString);
                const today = new Date();
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);

                if (date.toDateString() === today.toDateString()) {
                    return 'Today';
                } else if (date.toDateString() === yesterday.toDateString()) {
                    return 'Yesterday';
                } else {
                    return date.toLocaleDateString('en-US', { 
                        weekday: 'long', 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric' 
                    });
                }
            }

            formatTime(dateString) {
                return new Date(dateString).toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }

            updateStats() {
                const total = this.tasks.length;
                const completed = this.tasks.filter(t => t.completed).length;
                const pending = total - completed;

                this.stats.innerHTML = `
                    <div class="stat-item">
                        <div class="stat-dot pending"></div>
                        <span>Pending: ${pending}</span>
                    </div>
                    <div class="stat-item">
                        <div class="stat-dot completed"></div>
                        <span>Completed: ${completed}</span>
                    </div>
                `;
            }

            render() {
                this.updateStats();
                
                if (this.tasks.length === 0) {
                    this.content.innerHTML = '<div class="empty-state" id="emptyState"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/></svg><p>No tasks yet. Add your first backlog item above!</p></div>';
                    return;
                }

                const groupedTasks = this.groupTasksByDate();
                let html = '';

                Object.entries(groupedTasks)
                    .sort(([dateA], [dateB]) => new Date(dateB) - new Date(dateA))
                    .forEach(([date, tasks]) => {
                        html += `
                            <div class="date-section">
                                <div class="date-header">${this.formatDate(date)}</div>
                        `;
                        
                        tasks.forEach(task => {
                            html += `
                                <div class="task-item ${task.completed ? 'completed' : 'pending'}">
                                    <div class="checkbox ${task.completed ? 'checked' : ''}" onclick="app.toggleTask('${task.id}')"></div>
                                    <div class="task-text ${task.completed ? 'completed' : ''}">${task.text}</div>
                                    <div class="task-time">${this.formatTime(task.createdAt)}</div>
                                    <button class="delete-btn" onclick="app.deleteTask('${task.id}')">‚úï</button>
                                </div>
                            `;
                        });
                        
                        html += '</div>';
                    });

                this.content.innerHTML = html;
            }

            async saveTasks() {
                try {
                    if (window.electronAPI) {
                        await window.electronAPI.saveTasks(this.tasks);
                    } else {
                        // Fallback for web version
                        const data = JSON.stringify(this.tasks);
                        window.backlogData = data;
                    }
                } catch (error) {
                    console.error('Failed to save tasks:', error);
                }
            }

            async loadTasks() {
                try {
                    if (window.electronAPI) {
                        const result = await window.electronAPI.loadTasks();
                        return result.success ? result.data : [];
                    } else {
                        // Fallback for web version
                        const data = window.backlogData || '[]';
                        return JSON.parse(data);
                    }
                } catch (error) {
                    console.error('Failed to load tasks:', error);
                    return [];
                }
            }
        }

        // Initialize the app
        const app = new BacklogTracker();


        // Tabs toggle
const tasksTab = document.getElementById('tasksTab');
const scribbleTab = document.getElementById('scribbleTab');
const aiTab = document.getElementById('aiTab');
const tasksSection = document.getElementById('tasksSection');
const scribbleSection = document.getElementById('scribbleSection');
const aiSection = document.getElementById('aiSection');
const scribbleArea = document.getElementById('scribbleArea');

tasksTab.addEventListener('click', () => {
  tasksTab.classList.add('active');
  scribbleTab.classList.remove('active');
  aiTab.classList.remove('active');
  tasksSection.classList.add('active');
  scribbleSection.classList.remove('active');
  aiSection.classList.remove('active');
});

scribbleTab.addEventListener('click', () => {
  scribbleTab.classList.add('active');
  tasksTab.classList.remove('active');
  aiTab.classList.remove('active');
  scribbleSection.classList.add('active');
  tasksSection.classList.remove('active');
  aiSection.classList.remove('active');
});

aiTab.addEventListener('click', () => {
  aiTab.classList.add('active');
  tasksTab.classList.remove('active');
  scribbleTab.classList.remove('active');
  aiSection.classList.add('active');
  tasksSection.classList.remove('active');
  scribbleSection.classList.remove('active');
});

// Scribble autosave
scribbleArea.addEventListener('input', async () => {
  if (window.electronAPI) {
    await window.electronAPI.saveScribble(scribbleArea.value);
  } else {
    window.scribbleData = scribbleArea.value;
  }
});

// Load scribble
async function loadScribble() {
  if (window.electronAPI) {
    const result = await window.electronAPI.loadScribble();
    if (result.success) {
      scribbleArea.value = result.data;
    }
  } else {
    scribbleArea.value = window.scribbleData || '';
  }
}
loadScribble();


// AI Section functionality
class AIAssistant {
  constructor() {
    this.prompts = [];
    this.selectedPrompt = null;
    this.promptInput = document.getElementById('promptInput');
    this.savePromptBtn = document.getElementById('savePromptBtn');
    this.promptsList = document.getElementById('promptsList');
    this.userInput = document.getElementById('userInput');
    this.generateBtn = document.getElementById('generateBtn');
    this.aiResponse = document.getElementById('aiResponse');
    this.copyResponseBtn = document.getElementById('copyResponseBtn');
    
    this.init();
  }

  async init() {
    await this.loadPrompts();
    this.savePromptBtn.addEventListener('click', () => this.savePrompt());
    this.promptInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') this.savePrompt();
    });
    this.generateBtn.addEventListener('click', () => this.generateResponse());
    this.copyResponseBtn.addEventListener('click', () => this.copyResponse());
    this.renderPrompts();
  }

  async savePrompt() {
    const text = this.promptInput.value.trim();
    if (!text) return;

    const prompt = {
      id: Date.now().toString(),
      text: text,
      createdAt: new Date().toISOString()
    };

    this.prompts.unshift(prompt);
    await this.savePromptsToFile();
    this.promptInput.value = '';
    this.renderPrompts();
  }

  async deletePrompt(id) {
    this.prompts = this.prompts.filter(p => p.id !== id);
    if (this.selectedPrompt && this.selectedPrompt.id === id) {
      this.selectedPrompt = null;
    }
    await this.savePromptsToFile();
    this.renderPrompts();
  }

  selectPrompt(id) {
    this.selectedPrompt = this.prompts.find(p => p.id === id);
    this.renderPrompts();
  }

  renderPrompts() {
    if (this.prompts.length === 0) {
      this.promptsList.innerHTML = '<div style="padding: 20px; text-align: center; color: #888;">No saved prompts yet. Add your first prompt above!</div>';
      return;
    }

    let html = '';
    this.prompts.forEach(prompt => {
      const isSelected = this.selectedPrompt && this.selectedPrompt.id === prompt.id;
      html += `
        <div class="prompt-item ${isSelected ? 'selected' : ''}" onclick="aiAssistant.selectPrompt('${prompt.id}')">
          <div class="prompt-text">${prompt.text}</div>
          <button class="delete-prompt-btn" onclick="event.stopPropagation(); aiAssistant.deletePrompt('${prompt.id}')">‚úï</button>
        </div>
      `;
    });
    this.promptsList.innerHTML = html;
  }

  async generateResponse() {
    if (!this.selectedPrompt) {
      alert('Please select a prompt first!');
      return;
    }

    const userText = this.userInput.value.trim();
    if (!userText) {
      alert('Please enter some text to process!');
      return;
    }

    this.generateBtn.disabled = true;
    this.generateBtn.textContent = 'Generating...';
    this.aiResponse.textContent = 'Processing your request...';

    try {
      // Get config from configManager
      const config = await configManager.getConfig();
      if (!config.host || !config.port || !config.model) {
        throw new Error('Ollama not configured. Please click "Configure Ollama" button.');
      }

      // Call Ollama API
      const fullPrompt = `${this.selectedPrompt.text}\n\nInput: ${userText}`;
      const ollamaUrl = `http://${config.host}:${config.port}/api/generate`;
      
      const response = await fetch(ollamaUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: config.model,
          prompt: fullPrompt,
          stream: false
        })
      });

      if (!response.ok) {
        throw new Error(`Ollama API error: ${response.status}`);
      }

      const data = await response.json();
      this.aiResponse.textContent = data.response || 'No response received';
      this.copyResponseBtn.disabled = false;
    } catch (error) {
      console.error('Error calling Ollama:', error);
      this.aiResponse.textContent = `Error: ${error.message}\n\nMake sure Ollama is running and properly configured.\nClick "Configure Ollama" button to set up.`;
      this.copyResponseBtn.disabled = true;
    } finally {
      this.generateBtn.disabled = false;
      this.generateBtn.textContent = 'Generate Response';
    }
  }

  async copyResponse() {
    const text = this.aiResponse.textContent;
    if (text === 'Response will appear here...') return;

    try {
      await navigator.clipboard.writeText(text);
      const originalText = this.copyResponseBtn.textContent;
      this.copyResponseBtn.textContent = '‚úì Copied!';
      setTimeout(() => {
        this.copyResponseBtn.textContent = originalText;
      }, 2000);
    } catch (error) {
      console.error('Failed to copy:', error);
      alert('Failed to copy to clipboard');
    }
  }

  async savePromptsToFile() {
    try {
      if (window.electronAPI) {
        await window.electronAPI.savePrompts(this.prompts);
      } else {
        window.promptsData = JSON.stringify(this.prompts);
      }
    } catch (error) {
      console.error('Failed to save prompts:', error);
    }
  }

  async loadPrompts() {
    try {
      if (window.electronAPI) {
        const result = await window.electronAPI.loadPrompts();
        this.prompts = result.success ? result.data : [];
      } else {
        const data = window.promptsData || '[]';
        this.prompts = JSON.parse(data);
      }
    } catch (error) {
      console.error('Failed to load prompts:', error);
      this.prompts = [];
    }
  }
}

// Initialize AI Assistant
const aiAssistant = new AIAssistant();


// Configuration Manager
class ConfigManager {
  constructor() {
    this.config = {
      host: 'localhost',
      port: '11434',
      model: ''
    };
    this.modal = document.getElementById('configModal');
    this.configBtn = document.getElementById('configBtn');
    this.closeModal = document.getElementById('closeModal');
    this.testConnectionBtn = document.getElementById('testConnectionBtn');
    this.saveConfigBtn = document.getElementById('saveConfigBtn');
    this.ollamaHost = document.getElementById('ollamaHost');
    this.ollamaPort = document.getElementById('ollamaPort');
    this.modelSelect = document.getElementById('modelSelect');
    this.connectionStatus = document.getElementById('connectionStatus');
    this.modelSection = document.getElementById('modelSection');
    this.configStatus = document.getElementById('configStatus');
    
    this.init();
  }

  async init() {
    await this.loadConfig();
    await this.updateStatus();
    
    this.configBtn.addEventListener('click', () => this.openModal());
    this.closeModal.addEventListener('click', () => this.closeModalFn());
    this.testConnectionBtn.addEventListener('click', () => this.testConnection());
    this.saveConfigBtn.addEventListener('click', () => this.saveConfig());
    
    // Close modal on outside click
    window.addEventListener('click', (e) => {
      if (e.target === this.modal) {
        this.closeModalFn();
      }
    });
  }

  openModal() {
    this.ollamaHost.value = this.config.host;
    this.ollamaPort.value = this.config.port;
    this.modal.classList.add('show');
    this.connectionStatus.textContent = '';
    this.connectionStatus.className = 'connection-status';
    this.modelSection.style.display = 'none';
    this.saveConfigBtn.disabled = true;
  }

  closeModalFn() {
    this.modal.classList.remove('show');
  }

  async testConnection() {
    const host = this.ollamaHost.value.trim() || 'localhost';
    const port = this.ollamaPort.value.trim() || '11434';
    
    this.testConnectionBtn.disabled = true;
    this.testConnectionBtn.textContent = 'Testing...';
    this.connectionStatus.textContent = 'Checking Ollama connection...';
    this.connectionStatus.className = 'connection-status info';
    
    try {
      const response = await fetch(`http://${host}:${port}/api/tags`, {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' }
      });
      
      if (!response.ok) {
        throw new Error('Ollama not responding');
      }
      
      const data = await response.json();
      
      if (!data.models || data.models.length === 0) {
        this.connectionStatus.textContent = '‚ö†Ô∏è Ollama is running but no models are installed. Please install a model using: ollama pull llama3.2:latest';
        this.connectionStatus.className = 'connection-status error';
        this.modelSection.style.display = 'none';
        this.saveConfigBtn.disabled = true;
      } else {
        // Populate model dropdown
        this.modelSelect.innerHTML = '<option value="">-- Select a model --</option>';
        data.models.forEach(model => {
          const option = document.createElement('option');
          option.value = model.name;
          option.textContent = `${model.name} (${this.formatSize(model.size)})`;
          if (model.name === this.config.model) {
            option.selected = true;
          }
          this.modelSelect.appendChild(option);
        });
        
        this.connectionStatus.textContent = `‚úì Connected! Found ${data.models.length} model(s). Please select a model below.`;
        this.connectionStatus.className = 'connection-status success';
        this.modelSection.style.display = 'block';
        
        // Enable save when model is selected
        this.modelSelect.addEventListener('change', () => {
          this.saveConfigBtn.disabled = !this.modelSelect.value;
        });
        
        if (this.modelSelect.value) {
          this.saveConfigBtn.disabled = false;
        }
      }
    } catch (error) {
      this.connectionStatus.textContent = `‚ùå Ollama is not configured or not running. Please make sure Ollama is installed and running on ${host}:${port}`;
      this.connectionStatus.className = 'connection-status error';
      this.modelSection.style.display = 'none';
      this.saveConfigBtn.disabled = true;
    } finally {
      this.testConnectionBtn.disabled = false;
      this.testConnectionBtn.textContent = 'Test Connection';
    }
  }

  formatSize(bytes) {
    if (bytes < 1024 * 1024 * 1024) {
      return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }
    return (bytes / (1024 * 1024 * 1024)).toFixed(1) + ' GB';
  }

  async saveConfig() {
    const selectedModel = this.modelSelect.value;
    if (!selectedModel) {
      alert('Please select a model');
      return;
    }
    
    this.config = {
      host: this.ollamaHost.value.trim() || 'localhost',
      port: this.ollamaPort.value.trim() || '11434',
      model: selectedModel
    };
    
    try {
      if (window.electronAPI) {
        await window.electronAPI.saveOllamaConfig(this.config);
      } else {
        localStorage.setItem('ollamaConfig', JSON.stringify(this.config));
      }
      
      await this.updateStatus();
      this.closeModalFn();
      alert('Configuration saved successfully!');
    } catch (error) {
      console.error('Failed to save config:', error);
      alert('Failed to save configuration');
    }
  }

  async loadConfig() {
    try {
      if (window.electronAPI) {
        const result = await window.electronAPI.loadOllamaConfig();
        if (result.success && result.data) {
          this.config = result.data;
        }
      } else {
        const saved = localStorage.getItem('ollamaConfig');
        if (saved) {
          this.config = JSON.parse(saved);
        }
      }
    } catch (error) {
      console.error('Failed to load config:', error);
    }
  }

  async getConfig() {
    return this.config;
  }

  async updateStatus() {
    if (this.config.model) {
      this.configStatus.textContent = `‚úì Connected: ${this.config.model} @ ${this.config.host}:${this.config.port}`;
      this.configStatus.className = 'config-status success';
    } else {
      this.configStatus.textContent = '‚ö†Ô∏è Not configured';
      this.configStatus.className = 'config-status error';
    }
  }
}

// Initialize Configuration Manager
const configManager = new ConfigManager();


    </script>
</body>
</html>
